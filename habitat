#!/usr/bin/env bash



function habitat_unset_function() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    if ! type -t "$1" 2>&1 > /dev/null; then
        return 1
    fi

    unset -f "$1"
}

function habitat_unset_variable() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    unset "$1"
}
function habitat_source() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    if [ ! -f "$1" ]; then
        return 1
    fi

    . "$1"
}
function habitat_call_function() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    if ! type -t "$1" 2>&1 > /dev/null; then
        return 1
    fi
    $1
}

##
# habitat_is_valid_plugin_name(plugin)
# check if a plugin name is valid through regex/grep. Used internally only
#
# plugin - 'author/repo' of the github url
##
function habitat_is_valid_plugin_name() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    local plugin_name="$1"
    if [ -z "$(echo "$plugin_name" | grep -i "^[a-z0-9]\{1,\}/[a-z0-9]\{1,\}$")" ]; then
        return 1
    fi
    return 0
}

##
# habitat_error(message*)
# print messages to STDERR
#
# message - any number of messages to print to STDERR
##
function habitat_error() {
    while [ $# -gt 0 ]; do
        local message="$1"; shift
        if [ -n "${message:-}" ]; then
            echo "Error: $message" 1>&2
        fi
    done
}

##
# habitat_debug(message*)
# print file descriptor 3 when debug is set. We print to
# and create a thrird file descriptor so that we wont interfere
# with stdout capture of other functions while we are here.
#
# message - any number of messages to print
##
function habitat_debug() {
    if [ -n "${habitat_debug_output:-}" ]; then
        exec 3>&1
        while [ $# -gt 0 ]; do
            local message="$1"; shift
            if [ -n "${message:-}" ]; then
                echo "Debug: $message" 1>&3
            fi
        done
        exec 3>&-
    fi
}

##
# habitat_cleanup()
# remove all function/variables from the environment that start with habitat_
##
function habitat_cleanup() {
    local func
    while read -r func; do
        if [ "$func" = "habitat_cleanup" ]; then
            continue
        elif  [ "$func" = "habitat_debug" ]; then
            continue
        elif [ "$func" = "habitat_unset_function" ]; then
            continue
        elif [ "$func" = "habitat_unset_variable" ]; then
            continue
        fi
        habitat_debug "Unsetting function $func"
        habitat_unset_function "$func"
    done <<< "$(declare -F | grep "^declare -f habitat_" | sed 's~declare -f ~~g' )"

    local var
    while read -r var; do
        if [ "$var" = "habitat_debug_output" ]; then
            continue
        fi
        habitat_debug "Unsetting variable $var"
        habitat_unset_variable "$var"
    done <<< "$((set -o posix ; set) | sed -e 's~=.*~~' | grep -E "^habitat_")"


    habitat_debug "Unsetting function habitat_debug"
    habitat_debug "Unsetting variable habitat_debug_output"
    habitat_debug "Unsetting function habitat_cleanup"
    habitat_debug "Unsetting function habitat_unset_function"
    habitat_debug "Unsetting function habitat_unset_variable"

    habitat_unset_function "habitat_debug"
    habitat_unset_variable "habitat_debug_output"
    habitat_unset_function "habitat_cleanup"
    habitat_unset_function "habitat_unset_variable"
    habitat_unset_function "habitat_unset_function"
    return 0
}


##
# habitat_source_installed_plugins()
# source run, setup, and usage functions from plugins
##
function habitat_source_installed_plugins() {
    local base_dir="$1"
    local author_dir
    local plugin_file
    for author_dir in "$base_dir/"*; do
        # as this would normally be a long dir rather than just the author name
        local author="$(basename "$author_dir")"
        if [ "$author" = "*"  ]; then
            habitat_debug "Found no authors in installed plugins"
            return 1
        fi
        for plugin_file in "$author_dir/"*; do
            local plugin="$(basename "$plugin_file")"
            if [ "$plugin" = "*"  ]; then
                habitat_error "Found no plugins for author $author"
                break
            fi
            if ! habitat_is_valid_plugin_name "$author/$plugin"; then
                habitat_error "it appears there is an invalid plugin named $author/$plugin, skipping"
                continue
            fi

            habitat_debug "Sourcing plugin $author/$plugin in environment"
            habitat_source "$plugin_file"
            echo "${author}_${plugin}"
        done
    done
    return 0
}


##
# habitat_run()
# run plugin setup and run functions
##
function habitat_run() {
    local plugin_list="${1-}"
    local plugin_name
    if [ -z "${plugin_list:-}" ]; then
        return 1
    fi
    for plugin_name in $plugin_list; do
        if ! habitat_is_valid_plugin_name "$plugin_name"; then
            habitat_error "it appears there is an invalid plugin named $plugin_name"
            continue
        fi

        local plugin_name_underscore="$(echo "$plugin_name" | sed 's~/~_~')"
        local function_name="habitat_${plugin_name_underscore}_run"
        habitat_debug "Going to run $function_name"
        if ! habitat_call_function "$function_name"; then
            habitat_error "$plugin_name does not have a run function"
        fi
    done
}




##
# habitat_stub(plugin)
# stub out a new plugin
#
# plugin - 'author/repo' of the github url
##
function habitat_stub() {
    if  [ -z "${1:-}" ]; then
        habitat_error "There is a problem with habitat_stub it is not being passed the installation dir"
        return  1
    fi
    local installation_dir="$1"; shift
    if [ -z "${1:-}" ]; then
        habitat_error "Please pass in author/repo"
        return 1
    fi
    local plugin_name="$1"

    # verify plugin name
    if ! habitat_is_valid_plugin_name "$plugin_name"; then
        habitat_error "Please pass in a valid plugin name and not $plugin_name"
        return 1
    fi


    local plugin_underscore_name="$(echo "$plugin_name" | sed 's~/~_~')"
    local plugin_file="$installation_dir/$plugin_name"

    if [ -s "$plugin_file" ]; then
        habitat_error "$plugin_name already exists!!"
        return 1
    fi

    local author_dir="$(dirname "$plugin_file")"
    if [ ! -d "$author_dir" ]; then
        mkdir -p "$author_dir"
    fi

    local stub_contents="#!/usr/bin/env bash
function habitat_${plugin_underscore_name}_run() {
    # This is where you do the main thing that your plugin does
    :
}

function habitat_${plugin_underscore_name}_options() {
    # Arguments can be passed to your plugin from here
    :
}

"

    habitat_debug "Creating stub for $plugin_name in $plugin_file"
    habitat_debug "With Contents" "$stub_contents"
    echo "$stub_contents" > "$plugin_file"
    return 0
}





##
# habitat_usage(plugin)
# show usage information
#
# plugin - 'author/repo' of plugin tp show usage for
##
function habitat_usage() {
        echo
        echo "  . habitat <options>"
        echo
        echo "  add       add (a) plugin(s). use --save write a config change"
        echo "  rm        remove (a) plugin(s). use --save to write a config change"
        echo "  stub      stub a plugin in ${habitat_plugins_dir}. ex: stub author/plugin_name"
        echo "  help      show this help menu or plugin help. ex: help author/plugin_name"
        echo "  --debug   show debug statements to stdout"
    #    echo "  ls        show installed plugins"
    #    echo "  update    go through a plugin update progress"
    #    echo "  install   install plugins based upon config file"
        echo
}


##
# habitat_add(plugin*)
# add plugins, pass --save as plugin variable to save additions to config
#
# plugin - any number of 'author/repo' to add
##
function habitat_add() {
    while [ $# -gt 0 ] ; do
        local plugin="$1"; shift
        if [ -z "$plugin" ]; then
            continue
        fi
        local dir="$habitat_plugins_dir/$plugin"
        if [ -d "$dir"  ]; then
            habitat_error "Plugin $plugin appears to already be installed"
            continue
        fi

        # need to decalre local variables before capture
        # or else we won't correctly grab the result code
        local output=""
        output="$(git clone "https://github.com/$plugin" "$dir")"
        if [ "$?" -ne "0" ]; then
            habitat_error "Git Failed" "$output"
            continue
        fi
        if [ ! -f "$habitat_plugins_dir/$plugin/habit" ]; then
            habitat_error "Plugin $plugin does not contain a habit file removing"
            if [ -d "$dir" ]; then
                rm -rf "$dir"
            fi
            continue;
        fi
        echo "Plugin $plugin installed successfully"
        if [ -n "$habitat_save_to_config" ]; then
            local plugins="$(habitat_get_config "habitat_plugins_dir")"
            if [ -n "$plugins" ]; then
                plugins="$plugins "
            fi
            habitat_write_config "habitat_plugins_dir" "${plugins}${plugin}"
        fi
    done
}

##
# habitat_rm(plugin*)
# remove plugins, pass --save as plugin variable to save removals to config
#
# plugin - any number of 'author/repo' to remove
##
function habitat_rm() {
    while [ $# -gt 0 ] ; do
        local plugin="$1"; shift;
        if [ -z "$plugin" ]; then
            continue
        fi
        local dir="$habitat_plugins_dir/$plugin"
        if [ ! -d "$dir" ]; then
            habitat_error "Plugin $plugin does not exist"
            continue
        fi
        rm -rf "$dir"
        echo "Successfully Removed plugin $plugin"
        if [ -n "$habitat_save_to_config" ]; then
            local plugins="$(habitat_get_config "habitat_plugins_dir" | sed "s~$plugin~~")"
            habitat_write_config "habitat_plugins_dir" "${plugins}${plugin}"
        fi
    done
}

##
# habitat_read_config(key)
# read a value from the config given its key
#
# key - key to grab the value of
##
function habitat_read_config() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    local config="$1"; shift
    if [ -z "${1:-}" ]; then
        return 1
    fi
    local key="$1"; shift
    if [ ! -f "$config" ]; then
        mkdir -p "$(dirname "$config")"
        touch "$config"
    fi
    result="$(cat "$config" | grep "$key" | sed "s~$key=~~")"
    if [ -z "$result" ]; then
        result="$(echo "")"
    fi
    if [ "$(echo "$result" | wc -l)" -gt 1 ]; then
        habitat_error "Duplicate key for $key going to use first. Has values $result"
        result="$(echo "$result" | head -n 1)"
    fi
    echo "$result"
    habitat_debug "Found that $key was $result in config file"
}

##
# habitat_write_config(key, val)
# write a key value pair to the config file
#
# key - key to set
# val - value to set the key to
##
function habitat_write_config() {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    local file="$1"; shift
    if [ -z "${1:-}" ]; then
        return 1
    fi
    local key="$1"; shift
    local val=""
    if [ -n "${1:-}" ]; then
        val="$1"; shift
    fi
    local contents=""
    if [ -f "$file" ]; then
        contents="$(cat "$file")"
    fi

    local matches="$(echo "$contents" | grep "$key=" | wc -l)"
    if [ "$matches" -gt 1 ]; then
        habitat_error "Found $matches duplicate keys of $key in config file going to change all"
    fi

    if [ "$matches" -gt 0 ]; then
        echo "$contents" | sed "s~$key=.*~$key=$val~g" > $file
    else
        echo "${key}=${val}" >> "$file"
    fi
}




##
# habitat_update()
# update all installed plugins with .git directories
##
function habitat_update() {
    local author
    local plugin
    for author in "$habitat_plugins_dir/"*; do
        for plugin in "$author/"*; do
            if [ -d "$plugin/.git" ]; then
                habitat_debug "Going to update $plugin"
                "$(cd $plugin && git pull "$plugin")"
                . $plugin/habit
            else
                habitat_debug "Cannot update $plugin as it is not in git"
            fi
        done
    done
}


##
# habitat_update()
# check if the user wants certain first_time functionality
##
function habitat_first_time_setup() {
    # create config and default values
    :
}

##
# habitat_check_update()
# check wether their are updates for the habitat cli or plugins
##
function habitat_check_update() {
    :
}

##
# habitat_manage()
# add plugins based on config file, and source them
##
function habitat_manage() {
    :
}




##
# habitat_main(parent_lineno, message, code)
# parent_lineno - line number reported by the trap
# message       - error message
# code          - code to exit with
##
function habitat_trap_error() {
    local parent_lineno="${1:-}"; shift
    local message="${1:-}"; shift
    local code="${1:-1}"; shift

    if [ -z "$message" ]; then
        message=""
    fi
    habitat_error "Error on or near line ${parent_lineno}: ${message}; exiting with status ${code}"
    habitat_cleanup
    return "${code}"
}



##
# habitat_main($@)
# $@ - all args that have been passed to the script
##
function habitat_main() {
    # grab out --save and --debug
    habitat_argument_count="${#:0}"
    while [ $habitat_argument_count -gt 0 ]; do
        habitat_argument="$1"; shift
        if [ "$habitat_argument" = "--save" ]; then
            habitat_save_to_config="1"
        elif [ "$habitat_argument" = "--debug" ]; then
            habitat_debug_output="1"
        else
            set -- "$@" "$habitat_argument"
        fi
        habitat_argument_count=$((habitat_argument_count-1))
    done

    # throw errors if --save is passed in a bad way
    if [ -n "${habitat_save_to_config:-}" ] && [ -z "${1:-}" ]; then
        habitat_error "--save will do nothing without being used with add or rm"
        return 1
    elif [ -n "${habitat_save_to_config:-}" ] && [ -n "${1:-}" ]; then
        if [ "$1" != 'add' ] || [ "$1" != "rm" ]; then
            habitat_error "--save will do nothing with action $1"
        fi
    fi


    if [ -n "${1:-}" ]; then
        habitat_option="$1"; shift
        if [ "$habitat_option" = "help" ]; then
            habitat_usage "$@"
        elif [ "$habitat_option" = "add" ]; then
            habitat_add "$@"
        elif [ "$habitat_option" = "rm" ]; then
            habitat_rm "$@"
        elif [ "$habitat_option" = "stub" ]; then
            habitat_stub "$habitat_installed_plugins_dir" "$@"
        elif [ "$habitat_option" = "update" ]; then
            habitat_update"$@"
        elif type -t habitat_"$(echo "$habitat_option" | sed 's~/~_~')"_options; then
            habitat_"$(echo "$habitat_option" | sed 's~/~_~')"_options "$@"
        else
            habitat_error "Unknown option ${habitat_option}. Use help for usage"
            return 1
        fi
    else
        habitat_update
        habitat_manage
        habitat_run "$habitat_installed_plugin_list"
    fi
}



# TODO: more dynamic way to get habitat_base
# Requirements
if [ -z "$HOME" ]; then
    habitat_error "habitat_base must be defined in your environment to use habitat"
    return 1
fi

if ! command -v git > /dev/null; then
    habitat_error "git must be installed to use habitat!"
    return 1
fi


# defines
habitat_base_dir="$HOME/Projects/.habitat"
habitat_installed_plugins_dir="$habitat_base_dir/plugins/installed"
habitat_git_plugins_dir="$habitat_base_dir/plugins/git"
habitat_cli_file="$habitat_base_dir/habitat"
habitat_dotfiles_dir="$habitat_base_dir/dotfiles"
habitat_config_file="$habitat_base_dir/habitatrc"
habitat_run_unit_test=""

# Ever Changing Data
habitat_start_seconds="$(date +%s)"
habitat_save_to_config=""
habitat_version="1.0.0"
alias habitat=". $habitat_cli_file"

if [ -n "${1:-}" ] && [ "$1" = "--unit_testing" ]; then
    habitat_run_unit_test="1"
fi

# if unit testing dont automatically run anything
if [ -z "$habitat_run_unit_test" ]; then

    trap -- 'habitat_trap_error ${LINENO}' ERR SIGTERM SIGINT SIGHUP SIGQUIT
    if [ ! -f "$habitat_config_file" ]; then
        habitat_first_time_setup
    fi

    habitat_debug_output=""
    habitat_installed_plugin_list="$(habitat_source_installed_plugins "$habitat_installed_plugins_dir")"


    habitat_main "$@"

    # Cleanup our internal functions
    habitat_cleanup
    trap --
fi
