#!/usr/bin/env bash

##
# habitat_error(message*)
# print messages to STDERR
#
# message - any number of messages to print to STDERR
##
habitat_error() {
  while [ $# -gt 0 ]; do
    local message="$1"; shift
    if [ -n "${message:-}" ]; then
      echo "Error: $message" 1>&2
    fi
  done
}

##
# habitat_unset
# unset a variable/function
#
# name - name of the variable or function to unset
##
habitat_unset() {
  eval "if [ -n \"\${$1+x}\" ]; then
    unset \"$1\"
  fi"
  if type -t "$1" 2>&1 > /dev/null; then
    unset -f "$1"
  fi
}

##
# habitat_cleanup()
# remove all function/variables from the environment that start with habitat_
##
habitat_cleanup() {
  local func
  while read -r func; do
    case "$func" in
      habitat_cleanup|habitat_unset) continue;;
      *) habitat_unset "$func" && echo "Unsetting function $func";;
    esac
  done <<< "$(declare -F | grep "^declare -f habitat_" | sed 's~declare -f ~~g' )"

  local var
  while read -r var; do
    case "$var" in
      habitat_root) continue;;
      *) habitat_unset "$var" && echo "Unsetting variable $var"
    esac
  done <<< "$((set -o posix ; set) | sed -e 's~=.*~~' | grep -E "^habitat_")"
  echo "Unsetting fn habitat_cleanup"
  echo "Unsetting fn habitat_unset"
  habitat_unset "habitat_cleanup"
  habitat_unset "habitat_unset"
}

habitat_get_plugins() {
  dir="$1"; shift;
  find "$dir" -name 'habitat-*'
}

habitat_do() {
  local fn_name="$1"; shift;
  local plugins="$1"; shift;
  local old_ifs="$IFS"
  local plugin=
  IFS="$habitat_new_line"
  for plugin in $plugins; do
    . "${plugin}/${fn_name}.habit" 2>/dev/null || habitat_error "$plugin has no ${fn_name}.habit file"
  done
  IFS="$old_ifs"
}

##
# habitat_env_sanity()
# verify that we are working in a sane environment
##
habitat_env_sanity() {
  if ! command -v git > /dev/null; then
    habitat_error "git must be installed to use habitat!"
    return 1
  fi

  if [ -n "$habitat_root" ] || [ ! -f "$habitat_root/deps/bin/habitat" ]; then
    return 0
  fi

  if  [ -f "${XDG_CONFIG_HOME:=$HOME/.config}/habitat/deps/bin/habitat" ]; then
    habitat_root="$XDG_CONFIG_HOME/habitat"
    return 0
  elif  [ -f "$HOME/.habitat/deps/bin/habitat" ]; then
    habitat_root="$HOME/.habitat"
    return 0
  fi

  habitat_error "habitat_root must be defined, and have habitat installed there"
  return 1

}

habitat_main() {
  habitat_deps="$habitat_root/deps"
  habitat_bin="$habitat_root/deps/bin/habitat"
  habitat_dot="$habitat_root/dotfiles"

  alias habitat=". '$habitat_bin'"
  habitat_do "pre" "$habitat_plugins"
  habitat_do "run" "$habitat_plugins"
  habitat_do "post" "$habitat_plugins"
  habitat_plugins="$(habitat_get_plugins "$habitat_deps")"

}

if [ -n "${habitat_unit_test:-}" ]; then
  habitat_error "habitat was sourced in unit test mode"
  return 0
fi

if [ -n "$1" ] && [ -z "$habitat_root" ]; then
  habitat_root="$1"; shift
fi

if ! habitat_env_sanity; then
  # we can only return here if we are sourced
  # which is what we want in that case. When we run
  # the script as an executable we exit
  habitat_cleanup
  return 1 >/dev/null 2>&1 || exit 1
fi
habitat_new_line="
"

habitat_main
habitat_cleanup
return 0 >/dev/null 2>&1 || exit 0
